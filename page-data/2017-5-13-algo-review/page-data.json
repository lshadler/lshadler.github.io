{"componentChunkName":"component---src-templates-post-tsx","path":"/2017-5-13-algo-review/","webpackCompilationHash":"d17ef33ab51981bee811","result":{"data":{"site":{"siteMetadata":{"title":"lshadler.github.io","description":"A personal website for Lucas Shadler","author":{"name":"Lucas Shadler","url":"https://github.intuit.com/lshadler"}}},"markdownRemark":{"html":"<h2>Basic Concepts</h2>\n<h3>Complexity</h3>\n<p>An algorithm is efficient if it runs in polynomial time or better.</p>\n<h4>Big-O</h4>\n<p>Denotes worst case running time, a bound on the largest possible run time given\ninput of size N.\nTheta is lower and upper bound</p>\n<blockquote>\n<p>1 &#x3C; log n &#x3C; n &#x3C; n log n &#x3C; n^2 &#x3C; n^3 &#x3C; a^n &#x3C; n!</p>\n</blockquote>\n<h4>Amortized</h4>\n<p>Average running time per operation over a worst-case sequence of operation</p>\n<ul>\n<li>\n<p>Ex. Size-doubling array: 2^n operation every 2^ith step, but constant step\notherwise. Hence, O(n) with constant amortized time</p>\n<h3>Stable Matching</h3>\n<p>Given a set of preferences among hospitals and medical school students, design\na self-reinforcing admissions process</p>\n</li>\n<li>\n<p>Unstable paier: x and y are unstable if</p>\n<ul>\n<li>x prefers y and y prefers x to their assigned groupign</li>\n</ul>\n</li>\n<li>Stable Assignment: Assignment with no unstable pairs</li>\n<li>\n<p>Perfect matching: Everyone has a single unique match</p>\n<h4>Propose-and-reject algorithm</h4>\n</li>\n<li>Gale-Shapely</li>\n<li>Guarantees a stable matching for any problem</li>\n<li>\n<p>Gives a proposing-optimal assignment</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while some man is free and hasn&#39;t proposed to every woman\nchoose such a man m\nw = first woman on m&#39;s list he has not proposed to\nif w is free\n\tassign m and w together\nelse if w prefers m to her fiance m&#39;\n\tassign m and w to be engaged, m&#39; is free\nelse\n\tw rejects m</code></pre></div>\n<h3>Data Structures</h3>\n<h4>Linked List</h4>\n</li>\n<li>Each data node is linked to the next</li>\n<li>Access: O(n)</li>\n<li>Insert: O(1)</li>\n<li>head - first node in list</li>\n<li>\n<p>tail - last node in list</p>\n<h4>Stack</h4>\n</li>\n<li>Last in, First out</li>\n<li>Access: O(1)</li>\n<li>Insert: O(1)</li>\n<li>push(), pop()</li>\n<li>\n<p>Implement with linked list</p>\n<h4>Queue</h4>\n</li>\n<li>First in, First out</li>\n<li>Access: O(1)</li>\n<li>\n<p>Insert: O(1) if doubly linked list</p>\n<h4>Searching</h4>\n</li>\n<li>A <strong>linear search</strong> can be performed on a sorted sequence O(n)</li>\n<li>\n<p><strong>Binary Search</strong>: Divide-and-conquer on sorted sequence O(log n)</p>\n<h4>Sorting</h4>\n</li>\n<li><strong>Bubble Sort</strong>: Arranges items by iterating over the sequence, putting larger\nvalues on the top piece by piece, swap if left > right adjacent. O(n^2)</li>\n<li><strong>Selection Sort</strong>: Repeatedly select the next smallest item from unsorted\nitems O(n^2)</li>\n<li><strong>Insertion Sort</strong>: Iterates over sorted sequence, inserts the next\nunsorted item into its proper place O(n^2)</li>\n<li>\n<p><strong>Heap Sort</strong>: Build heap and extract keys in sorted sequence O(n log n)</p>\n<h4>Heap Trees</h4>\n<p>A heap is a complete binary tree in which the nodes are organied based on their\ndata values</p>\n</li>\n<li>Max heap: The value is greater than its two children</li>\n<li>Min heap: The value is smaller than its two children</li>\n<li>Can only remove from the root node</li>\n<li>Inserts in next available left/top location, and sift upwards</li>\n<li>\n<p>can be stored in a dynamic array</p>\n<ul>\n<li>parent = i // 2</li>\n<li>left = 2 * i</li>\n<li>right = 2 * i + 1</li>\n</ul>\n</li>\n<li>Insertion: O(log n)</li>\n<li>Extraction: O(log n)</li>\n<li>\n<p>Building</p>\n<ul>\n<li>Top down: Heaps constructed by inserting into an empty heap O(n log n)</li>\n<li>\n<p>Bottom up: Put everything in array and then fix O(n)</p>\n<h4>BST</h4>\n<p>Tree such that all keys less than current key is in the left subtree and all\nkeys greater than the key are stored in the right subtree</p>\n</li>\n</ul>\n</li>\n<li>Searching is trivial</li>\n<li>Can be built recursively or iteratively</li>\n<li>\n<p>Removing</p>\n<ul>\n<li>Remove interior node -></li>\n<li>Successor: Minimum key in right subtree</li>\n</ul>\n</li>\n<li>\n<p>Search, insert, delete: O(n)</p>\n<h5>AVL Trees</h5>\n<p>Developed by Adel’son-Velskhii and Landis to guarantee that the tree is height\nbalanced</p>\n<h3>Master Theorem</h3>\n</li>\n</ul>\n<h2>Algorithm Subcategories</h2>\n<h3>Divide and Conquer</h3>\n<ul>\n<li>Break up problem into several parts</li>\n<li>solve each part recursively</li>\n<li>combine solutions to sub-problems into overall solution</li>\n<li>\n<p>n^2 -> n log n</p>\n<h4>Mergesort</h4>\n</li>\n<li>Divide array into two halves</li>\n<li>recursively sort each half</li>\n<li>\n<p>merge two halves to make a sorted whole</p>\n<h4>Convex Hull</h4>\n<p>Given a set of points, find the smallest convex polygon containing all the\npoints</p>\n</li>\n</ul>\n<p>Graham-scan</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">start at bottom-left point\nsort points by relative polar angle\nbegin\n\tadd point to stack\n\tpop off if it creates a left turn</code></pre></div>\n<h4>Counting Inversion</h4>\n<p>Find number of inversions made to match two lists</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if list L has one element\n\treturn 0 and list L\nDivide L into two halves A and B\n(ra, A) = function(A)\n(rb, B) = function(B)\n(r, L)  = merge-and-count(A,B)\nreturn r = ra + rb + r and sorted list L</code></pre></div>\n<h3>Greedy Algorithms</h3>\n<ul>\n<li>Build up solutions in small steps</li>\n<li>Make local decisions</li>\n<li>\n<p>Previous decisions do not factor into the next consideration</p>\n<h4>Coin changing</h4>\n<p>Given currency denominations, devise a method to pay amount to customer using\nfewest number of coins</p>\n</li>\n<li>\n<p>At each iteration, add coin of largest value that does not take us past the\namount to be paid</p>\n<ul>\n<li>Optimal for US coinage</li>\n<li>\n<p>Suboptimal for other situations (1, 10, 21, 34, 70, 100):(140)</p>\n<h4>Interval Scheduling</h4>\n<p>Find the maximal subset of mutually compatible jobs</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Consider ordering</p>\n<ul>\n<li>Earliest Start time</li>\n<li>Earliest finish time</li>\n<li>Shortest interval</li>\n<li>fewest conflicts</li>\n<li><strong>Typically Finish Time is Optimal</strong></li>\n</ul>\n</li>\n<li>Unweighted solution: Take the next valid job based on finish time and no\nconflicts</li>\n<li>\n<p>O(n log(n))</p>\n<h4>Interval Partitioning</h4>\n<p>Find minimum number of classrooms to schedule all lectures so that no two occur\nat the same time</p>\n</li>\n<li>number of classrooms needed >= depth</li>\n<li>Sort by start time</li>\n<li>Assign lecture to any compatible classroom</li>\n<li>O(n log(n))</li>\n</ul>\n<h3>Dynamic Programming</h3>\n<p>Develop a solution as a solution to several subproblems, and get benefits in\nperformance as a result of the division of computation.</p>\n<h4>Weighted Interval Scheduling</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h4>Knapsack</h4>\n<p>Given:</p>\n<ul>\n<li>A collection of n items</li>\n<li>Each item has a weight w</li>\n<li>each item has a value c</li>\n<li>The knapsack has a total weight W</li>\n</ul>\n<p>Task:</p>\n<ul>\n<li>Determine set S of items of max value that can be contained in knapsack</li>\n</ul>\n<p>Divisible:</p>\n<ul>\n<li>\n<p>Items do not have to be included in entirety</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sort items in decresing order of c/w\ni = 1\ncurrentW = 0\nwhile currentW + w_i &lt; W\ntake item of weight w_i and cost c_i\ncurrentW += w_i\ni++\ntake W-currentW portion of item i</code></pre></div>\n<p>Indivisible:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function(n,c,w,W)\nif n &lt;= 0\nreturn 0\nif W &lt; w_n\nwithLastItem = -1\nelse\nwithLastItem = c_n + function(n-1,c,w,W-w_n)\nwithoutLastItem = function(n-1,c,w,W)\nreturn max{withLast,withoutLast}</code></pre></div>\n</li>\n<li>Create knapsack with subproblems</li>\n<li>\n<p>let S[k][v] := the solution with first k items and available weight v</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">init S[0][v] = 0\ninit S[k][0] = 0\nfor v from 1 to W\nfor k from 1 to n\n\tS[k][v] = S[k-1][v]\n\tif w_k &lt;= v and S[k-1][v-w_k] + c_k &gt; S[k][v]\n\t\tS[k][v] = S[k-1][v-w_k] + c_k\nreturn S[n][W]</code></pre></div>\n<h4>Longest Increasing Subsequence</h4>\n<h3>Graph Algorithms</h3>\n<p>A graph is usually defined as having a number of vertices V and a number of\nedges E with or without weights.</p>\n<h4>Prim’s Algorithm</h4>\n</li>\n<li>Finds Min-Span Tree</li>\n<li>Greedy</li>\n<li>\n<p>O(V^2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>Choose an arbitrary starting vertex</li>\n<li>Of edges that connect to the tree, add the minimum-weight one</li>\n<li>\n<p>Repeat until all vertices are accounted for</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#### Dijkstra&#39;s Algorithm</code></pre></div>\n</li>\n<li>Shortest path between nodes with non-negative edges</li>\n<li>\n<p>O(V^2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>Choose starting vertex</li>\n<li>Assign each node dist: 0 for starting, inf otherwise</li>\n<li>For current, consider all neighbors and calc tentative dists.\nCompare with previous value and assign smaller</li>\n<li>Mark the current node as visited and remove from unvisited set</li>\n<li>\n<p>if destination has been reached, terminate\nelse take ‘shortest’ unvisited node path, set as new current, and 3)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#### Floyd Warshall</code></pre></div>\n</li>\n<li>Compares all possible paths through the graph between each pair of vertices</li>\n<li>\n<p>O(V^3)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let dist be a |V| x |V| array of minimum dists at infinity\nfor each vertex v\ndist[v][v] = 0\nfor each edge (u,v)\ndist[u][v] = w(u,v) // the weight of the edge (u,v)\nfor k from 1 to |V|\nfor i from 1 to |V|\n\tfor j from 1 to |V|\n\t\tif dist[i]][j] &gt; dist[i][k] + dist[k][j]\n\t\t\tdist[i][j] = dist[i][k] + dist[k][j]\n\t\tend if</code></pre></div>\n<h4>Bellman-Ford</h4>\n</li>\n<li>Computes shortest path from source vertex to all other vertices</li>\n<li>Slower than Dijkstras</li>\n<li>but can handle negative values</li>\n<li>Runs in O(|V||E|)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for each vertex v in vertices:\n\tdist[v]    = inf\n\tpredecessor[v] = null;\ndist[source] = 0\n\nfor i from 1 to size(vertices)-1:\n\tfor each edge (u,v) with weight w in edges:\n\t\tif dist[u] + w &lt; dist[v]:\n\t\t\tdist[v] = dist[u] + w\n\t\t\tpredecessor[v] = u\n\nfor each edge (u,v) with weight w in edges:\n\tif dist[u] + w &lt; dist[v]:\n\t\terror &quot;Graph contains a negative-weight cycle&quot;\nreturn dist,predecessor</code></pre></div>\n<h4>Kruskal</h4>\n<h4>Ford-Fulkerson</h4>\n<ul>\n<li>Greedy Algorithm</li>\n<li>Computes maximum flow in a flow network</li>\n<li>Complexity: O(Ef); E edges, f maximum flow</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">given G = (V,E) with flow capacity c, source s, and sink t\nf(u,v) = 0 for all edges(u,v)\nwhile there is a path from s to t in G_f, with c_f(u,v) &gt; 0 for all edges:\n\tfind c_f(p) = min(c_f(u,v):(u,v))\n\tfor each edge (u,v)\n\t\tf(u,v) += c_f(p)\n\t\tf(v,u) -= c_f(p)</code></pre></div>","excerpt":"Basic ConceptsComplexityAn algorithm is efficient if it runs in polynomial time or better.Big-ODenotes worst case running time, a bound on…","frontmatter":{"title":"Algorithms Review Cheat Sheet"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2017-5-13-algo-review/"}}}